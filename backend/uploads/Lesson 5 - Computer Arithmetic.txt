COMPUTER ORGANIZATION AND ASSEMBLY LANGUAGEComputer ArithmeticInteger Representation, Integer ArithmeticCourse Instructor: Klarence M. Baptista, MITArithmetic & Logic UnitDoes the calculationsEverything else in the computer is there to service this unitHandles integersMay handle floating point (real) numbersMay be separate FPU (maths co-processor)May be on chip separate FPU (486DX +)ALU Inputs and OutputsInteger RepresentationOnly have 0 & 1 to represent everythingPositive numbers stored in binaryðŸž‘ e.g. 41=00101001No minus signNo periodSign-MagnitudeTwoâ€™s complimentSign-MagnitudeThe simplest form of representation that employs a sign bit is the sign-magnitude representationIn an n-bit word, the rightmost n-1 bits hold the magnitude of the integer  +18 = 00010010-18 = 10010010Sign-MagnitudeProblemsðŸž‘ Need to consider both sign and magnitude in arithmeticðŸž‘ Two representations of zero (+0 and -0)Inconvenient because it is slightly more difficult to test for 0 (an operation performed frequently on computers) than if there were a single representationSign-magnitude representation is rarely used in implementing the integer portion of the ALUInstead, the most common scheme is twos complement representationTwoâ€™s ComplimentLike sign magnitude, twos complement representation uses the most significant bit as a sign bit, making it easy to test whether an integer is positive or negativeIt differs from the use of the sign-magnitude representation in the way that the other bits are interpretedCharacteristics of Twos Complement Representation and ArithmeticTwoâ€™s Compliment  +3 = 00000011  +2 = 00000010  +1 = 00000001  +0 = 00000000-1 = 11111111-2 = 11111110-3 = 11111101Alternative Representations for 4-Bit IntegersBenefitsOne representation of zeroArithmetic works easilyNegating is fairly easyðŸž‘ 3 = 00000011ðŸž‘ Boolean complement gives11111100ðŸž‘ Add 1 to LSB11111101Negation Special Case 10 =Bitwise notAdd 1 to LSBResult0000000011111111+11 00000000Overflow is ignored, so:- 0 = 0Negation Special Case 2128 =bitwise notAdd 1 to LSBResultSo:-128 = 1281000000001111111+110000000Monitor MSB (sign bit)It should change during negationRange of Numbers8 bit 2s complimentðŸž‘ +127 = 01111111 = 27 -1ðŸž‘ -128 = 10000000 = -2716 bit 2s complimentðŸž‘ +32767 = 011111111 11111111 = 215 - 1ðŸž‘ -32768 = 100000000 00000000 = -215Conversion Between LengthsPositive number pack with leading zeros  +18 = 00010010  +18 = 00000000 00010010Negative numbers pack with leading ones-18 = 10010010-18 = 11111111 10010010i.e. pack with MSB (sign bit)Addition and SubtractionNormal binary additionMonitor sign bit for overflowTake twos compliment of substahend and add to minuendðŸž‘ i.e. a - b = a + (-b)So we only need addition and complement circuitsOverflowFor unsigned integers, overflow occurs when there is a carry out of the msb.1000 (8) +1001 (9) ----------- 1 0001 (1)For 2's complement integers, overflow occurs when the signs of the addends are the same, and the sign of the result is different0011 (3) + 0110 (6) ---------- 1001 (-7)(note that a correct answer would be 9, but 9 cannot be represented in 4-bit 2's complement)Hardware for Addition and SubtractionProblemsRepresent the following decimal numbers in both binary sign/magnitude and twos complement using 16 bits:I.+512-29II.Represent the following twos complement values in decimal:I.1101011II.0101101.ProblemAssume numbers are represented in 8-bit twos complement representation. Show the calculation of the following:III.I.6+13II.-6+136-13IV. -6-13ProblemFind the following differences using twos complement arithmetic:MultiplicationComplexWork out partial product for each digitTake care with place value (column)Add partial productsMultiplication Example1011 Multiplicand (11 dec)x 1101 Multiplier (13 dec)1011  Partial productspy0000Note: if multiplier bit is 1 co1011multiplicand (place value)101110001111otherwise zero Product (143 dec)Note: need double length resultUnsigned Binary MultiplicationExecution of ExampleFlowchart for Unsigned Binary MultiplicationDivisionMore complex than multiplicationNegative numbers are really bad!Based on long divisionDivision of Unsigned Binary Integers000011011011 10010011101100111010110011111011100QuotientDividendRemainderPartialRemaindersDivisorFlowchart for Unsigned Binary Division